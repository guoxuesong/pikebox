class DynamicDimensionRelationMap{
	array classifiers=({});
	int dimension(){return sizeof(classifiers);};
	mapping weak=([]);
	mapping strong=([]);
	private void insert(mapping store,object atom1,object atom2)/*{{{*/
	{
		store[atom1]=store[atom1]||(<>);
		store[atom1][atom2]=1;
		store[atom2]=store[atom2]||(<>);
		store[atom2][atom1]=1;
	}/*}}}*/
	private int is_nearby(object atom1,object atom2)/*{{{*/
	{
		return weak[atom1]&&weak[atom1][atom2]||strong[atom1]&&strong[atom1][atom2];
	}/*}}}*/
	void add_weak_relation(object atom1,object atom2){insert(weak,atom1,atom2);}
	void add_relation(object atom1,object atom2){insert(strong,atom1,atom2);}
	array expand_nearbyset(multiset curr,object atom)
	{
		multiset m=strong[atom];
		array a=({});
		foreach(multiset curr;object atom2;int one){
			multiset m2=stong[atom2]|weak[atom2];
			a+=({m2});
		}
		if(sizeof(a)){
			multiset res=`&(@a)-curr;
			return map((array)res,lambda(object a){
					return (<a>)|curr;
					});
		}
		//return ({});
	}
	array multiset_uniq(array a)/*{{{*/
	{
		array res=({});
		for(int i=0;i<sizeof(a);i++){
			int skip;
			for(int j=0;j<sizeof(res);j++){
				if(equal(a[i],res[j])){
					skip=1;
					break;
				}
			}
			if(!skip){
				res+=({a[i]});
			}
		}
		return res;
	}/*}}}*/
	array(multiset) create_nearbyset(object atom,int n)//返回在atom强周围选n个两两强或弱相邻原子的所有可能
	{
		array res=map((array)strong[atom],lambda(object a){
				return (<a>);
				});
		for(int i=0;i<n-1;i++){
			res=multiset_uniq(`+(({}),@map(res,expand_nearbyset,atom)));
		}
		return res;
	}
	void create_nodes()
	{
		mapping corners=([]);
		foreach(strong;object atom1;multiset m){
			corners[atom1]=create_nearbyset(atom1,dimension()-1);
		}
	}
}

